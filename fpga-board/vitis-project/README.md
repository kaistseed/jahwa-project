# Jahwa Electronics - Data Acquisition System Project Documentation
> <div align="justify"> This document covers all the information about the Jahwa Electronics data acquisition system project. It provides step-by-step instructions for writing FPGA firmware with Xilinx Vitis.</div>

--------------------------

## :bookmark_tabs: Table of Content

* [Context](#information_source-context)
* [Background](#mag-background)
* [Creating FPGA Design using Xilinx Vivado](#computer-writing-fpga-firmware-using-xilinx-vitis)
* [Creating a Python-based Software-Hardware Interface](#-creating-a-python-based-software-hardware-interface)
* [Tutorial Video](#movie_camera-tutorial-video)

---------------------------

## :information_source: Context

*Created by*: **Dalta Imam Maulana**
*Document Version*: **September 14th, 2023**

------------------

## :mag: Background

### Xilinx Vivado
<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/vivado-logo.png" alt="vivado-logo" width="40%" />
</p>


Vivado design suite is an integrated design environment (IDE) developed by Xilinx that provides a lot of features such as:

* Vivado high-level synthesis (HLS) compiler transforms C, C++, and SystemC programs into RTL code.
* Vivado simulator that supports mixed-language simulation and verification.
* Vivado IP integrator allows the designer to easily integrate and configure IP cores either a pre-built library from Xilinx or custom-made IP cores.



### Xilinx Vitis

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/vitis-logo.png" alt="vitis-logo" width="60%" />
</p>

Xilinx Vitis is an integrated design environment (IDE) for writing FPGA software. Vitis consists of multiple tools including Xilinx SDK, Vitis High-Level Synthesis (HLS), and SDSoC. The difference between each tool can be explained as follows:

* **Xilinx SDK**: Write application code based on C/C++ to run on a processor in the design that user created in Vivado. The code is usually used to control and configure hardware blocks connected to the processor.
* **Vitis HLS**: Write C/C++ code which then is translated to RTL (Verilog/VHDL) to be used as an IP block in Vivado project. The block generated by Vitis HLS can be loaded in Vivado for manual optimization.
* **Vitis SDSoC**: Write C/C++ code to be built into a block that the tool integrates into a previously created Vivado design. With the SDSoC, the user can accelerate particular data processing functions by building custom hardware blocks without manually designing the hardware block (writing the hardware block using software languages.)



### PYNQ Framework

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/pynq-logo.png" alt="pynq-logo" width="55%" />
</p>

PYNQ is an open-source Xilinx framework designed for system designers, software developers, and hardware designers to use Xilinx platforms easily. With the support of Python language and libraries, designers can benefit from using programmable logic and microprocessors to build more exciting and robust embedded systems. The PYNQ framework can now be used with Zynq, Zynq UltraScale+, Zynq RFSoC, and Alveo accelerator boards.

-------------

## :computer: Writing FPGA Firmware using Xilinx Vitis

The following section will guide you on how to write firmware for controlling MicroBlaze softprocessor and all of the IP blocks that are connected to the MicroBlaze such as SPI, IIC, Timer, and GPIO IP block.

### Create New Vitis Project


1. First, open up the Vitis application and create a new **application project**. After that, a new window will appear, and you need to set the location of the Vitis workspace. You can set the workspace to any location you want. 

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/vitis-workspace.png" alt="vitis-workspace" width="50%" />
   </p>

2. Next, you need to import the **hardware file** (.xsa file) generated when you make the FPGA overlay using Vivado. If you cannot find the hardware file, please refer to the Vivado project guide on how to create hardware file for your FPGA overlay.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/import-hardware.png" alt="import-hardware" width="100%" />
   </p>

3. After that, you need to set the application project details, such as the application project name, system project details, and target processor. You must choose the MicroBlaze processor for the target processor since you want to write the firmware for the MicroBlaze, not for the ARM processor.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/target-processor.png" alt="target-processor" width="75%" />
   </p>

4. The next step is to choose the type of operating system for the target processor. In this project, you will write a baremetal application or firmware for MicroBlaze without any operating system since the ARM processor will use the MicroBlaze processor to control all IP blocks.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/operating-system.png" alt="operating-system" width="75%" />
   </p>

5. After configuring all the application settings, you will be given the option to select a template project file. For this project, the firmware will be written using C language, so just choose **Empty Application** template.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/a9197fd801e5fbacc2df49b14cec5f30555d249c/documentation/resources/vitis-template.png" alt="vitis-template" width="75%" />
   </p>



### Updating Makefile for Custom IP Blocks and Initial Project Build

Before writing C code for the MicroBlaze firmware, you need to do an initial build to the project to check whether the hardware files imported from Vivado are correctly built. If you try building the project for the first time, most likely, you will encounter an error. This is due to a bug in the makefile when you have a custom-built IP block inside the design. In this project, the AXI clock divider for generating a trigger signal for the laser is a custom-built IP block. To fix the error, you should follow the following steps:


1. Open the makefile for building the AXI clock divider and replace it with this makefile. You can find the AXI clock divider makefile inside the libsrc directory of the MicroBlaze softprocessor. 

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/makefile.png" alt="makefile" width="100%" />
   </p>

2. After replacing the makefile, you can start building the project by clicking the hammer symbol on the toolbar

3. Check whether there are errors after the build process is finished. If the build is completed successfully, you can start writing the C code for controlling the MicroBlaze processor.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/debug-build.png" alt="debug-build" width="100%" />
   </p>



### Copying Source Code and Generate BIN File

1. Copy all libraries (C code) from the repository to the project src directory. In the repository, there are multiple C codes that contain basic functions for controlling each IP block. The list of the libraries that can be used is as follows:

    | Library Name | IP Block | Description | Reference |
    | :--- | :--- | :--- | :--- |
    | `circular_buffer`     | MicroBlaze | Contains functions that are used by MicroBlaze to write/read data to/from shared memory space | [PYNQ repository](https://github.com/Xilinx/PYNQ/blob/de6b6fc3a803945d59f8f06523addfe0d9b60a1c/boards/sw_repo/pynqmb/src/circular_buffer.h) |
    | `gpio`                | AXI GPIO | Contains functions that are used by MicroBlaze to control the GPIO operation | - |
    | `i2c`                 | AXI IIC | Contains basic functions that are used by MicroBlaze to initialize I2C protocol and perform basic I2C transaction | [PYNQ repository](https://github.com/Xilinx/PYNQ/blob/de6b6fc3a803945d59f8f06523addfe0d9b60a1c/boards/sw_repo/pynqmb/src/i2c.h) |
    | `meissner`            | AXI IIC | Contains high-level I2C functions that are specific to Meissner sensor | - |
    | `pytypes`             | MicroBlaze | Contains data type definitions to support Python - C interoperability | [PYNQ repository](https://github.com/Xilinx/PYNQ/blob/de6b6fc3a803945d59f8f06523addfe0d9b60a1c/boards/sw_repo/pynqmb/src/pytypes.h) |
    | `spi`                 | AXI Quad SPI | Contains functions that are used by MicroBlaze to perform SPI transactions for controlling ADC and DAC | [PYNQ repository](https://github.com/Xilinx/PYNQ/blob/de6b6fc3a803945d59f8f06523addfe0d9b60a1c/boards/sw_repo/pynqmb/src/spi.h) |
    | `timer`               | AXI Clock Divider | Contains functions that are used by MicroBlaze to delay the program accurately | [PYNQ repository](https://github.com/Xilinx/PYNQ/blob/de6b6fc3a803945d59f8f06523addfe0d9b60a1c/boards/sw_repo/pynqmb/src/timer.h) |

2. Write the main C code which controls the overall operation of the MicroBlaze processor. The basic structure of the main C code consists of defining the operation mode, initializing the IP blocks, and performing the operation based on the operation mode. The operation mode should be clearly defined in the code since the operation mode will be used by the PC client to control the MicroBlaze operation by writing the operation mode to the MicroBlaze shared memory space. The following code is an example of the main C code for controlling the MicroBlaze operation. You can find the full main C code in the repository.

   ```c
        /*****************************************************************************/
        /*                             Library Imports                               */
        /*****************************************************************************/
        // Basic Xilinx Library
        #include "xgpio.h"
        #include "xil_printf.h"
        #include "xparameters.h"
        #include "xil_exception.h" 

        // User-defined library
        #include "gpio.h"

        /*
        * The following constant is used to determine the operation of 
        * the microblaze system. 
        */
        // Define operation mode
        // GPIO operations
        #define GPIO_WRITE_LED 0x01
        #define GPIO_TEST_LED 0x02

        /*****************************************************************************/
        /*                              Main Function                                */
        /*****************************************************************************/
        int main(void) {
            // Declare local variables
            int mb_command;
            int xil_status;

            /*****************************************************************************/
            /*                               GPIO Setup                                  */
            /*****************************************************************************/
            // Initialize LED I/O
            led_io_init();

            /*****************************************************************************/
            /*                                Main Loop                                  */
            /*****************************************************************************/
            while(1) {
                // Wait for command from host
                while(MAILBOX_CMD_ADDR == 0x00);
                mb_command = MAILBOX_CMD_ADDR;

                // Perform operation based on command
                switch(mb_command) {
                    /*********************************************************************/
                    /*                         GPIO Operations                           */
                    /*********************************************************************/
                    case GPIO_WRITE_LED:
                        // Get data from host
                        mb_data_host[0] = MAILBOX_DATA(0);
                        // Control LED operation based on data
                        if(mb_data_host[0] == 1) {
                            // Set LED0 to high
                            led_0_on();
                        } else if(mb_data_host[0] == 2) {
                            // Set LED1 to high
                            led_1_on();
                        } else if(mb_data_host[0] == 3) {
                            // Set LED2 to high
                            led_2_on();
                        } else if(mb_data_host[0] == 4) {
                            // Set LED3 to high
                            led_3_on();
                        } else if(mb_data_host[0] == 5) {
                            // Set all LED to high
                            led_0_on();
                            led_1_on();
                            led_2_on();
                            led_3_on();
                        } else {
                            // Set all LED to low
                            led_0_off();
                            led_1_off();
                            led_2_off();
                            led_3_off();
                        }
                        // Clear command
                        MAILBOX_CMD_ADDR = 0x00;
                        break;

                    case GPIO_TEST_LED:
                        // Loop through LED0 and LED1
                        for(int i=0; i<5; i++) {
                            // Set LED0 to high
                            led_0_on();
                            // Wait 100 ms
                            delay_ms(100);
                            // Set LED1 to high
                            led_1_on();
                            // Wait 100 ms
                            delay_ms(100);
                            // Set LED2 to high
                            led_2_on();
                            // Wait 100 ms
                            delay_ms(100);
                            // Set LED3 to high
                            led_3_on();
                            // Wait 100 ms
                            delay_ms(100);
                        }
                        // Clear command
                        MAILBOX_CMD_ADDR = 0x00;
                        break;

                    /*********************************************************************/
                    /*                        Other Operations                           */
                    /*********************************************************************/
                    default:
                        // Clear command
                        MAILBOX_CMD_ADDR = 0x00;
                        break;
                }
            }
        }
   ```

3. After writing the main C code, you need to rebuild the project. This time, you need to build the project using the Vitis shell since you need to generate binary files for the MicroBlaze processor, which requires you to modify the makefile. You need to add lines, as in the figure below, to the makefile. You can also find the sample makefile in the repository.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/4779b6b419d4c1a326d93df15f45549d143e7d3e/documentation/resources/bin-makefile.png" alt="bin-makefile" width="100%" />
   </p>

4. Next, open the Vitis shell by clicking the white command prompt symbol in the toolbar

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/a9197fd801e5fbacc2df49b14cec5f30555d249c/documentation/resources/vitis-shell.png" alt="vitis-shell" width="100%" />
   </p>

5. After entering the shell, move to the debug directory inside the application project directory. The application project directory is located inside the workspace directory that you set when creating the application project. If you are not sure which directory is the application project directory, you can check the directory name by seeing the parent directory in which the src directory is located.
   
   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/4779b6b419d4c1a326d93df15f45549d143e7d3e/documentation/resources/vitis-directory.png" alt="vitis-directory" width="80%" />
   </p>

6. To check whether you are in the correct directory, you can type the command `dir` to see the list of files and directories inside the current directory and if you see the makefile, then you are in the correct directory.
7. Next, you can start building the project by typing the following command:

   ```bash
   make clean && make
   ```
   If the build is successful, you will see the newly created bin file inside the debug directory. Otherwise, you need to fix the error before proceeding to the next step.

-------------

## <img style="vertical-align:middle" src="https://github.com/kaistseed/jahwa-project/blob/4779b6b419d4c1a326d93df15f45549d143e7d3e/documentation/resources/python.png" width="32px" title=":python:"/> Creating a Python-based Software-Hardware Interface
The following section will guide you on how to create a Python-based software hardware interface using the PYNQ framework. The software hardware interface will be used to control the MicroBlaze processor and all of the IP blocks connected to the MicroBlaze processor. Additionally, the Python program will also be used to receive commands from the PC client through a TCP/IP socket connection and send the data acquired from the FPGA board to the PC client.

### Uploading Design from PC to PYNQ Board
To run the design on the PYNQ board, first, you need to upload the FPGA design from Vivado (.bit, .tcl, and .hwh files) and MicroBlaze firmware (.bin file) into the PYNQ board. You can upload the files to the board by following the steps below:

1. Open the PYNQ board Jupyter Notebook by entering **192.168.2.99** in the host computer browser address bar. If you canâ€™t access the PYNQ board Jupyter Notebook, please refer to the [**PYNQ Board Setup**](https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools.html) section in the Vivado guide.
2. Create a new folder called **project** by clicking **New** button in the Jupyter Notebook interface.
3. If you want, you can create another folder inside project folder, which is designated for each project you create. In this case, **jahwa_daq_system** folder.
4. Upload the **FPGA design files** (.bit, .tcl, and .hwh files) and **MicroBlaze firmware** (.bin file) into the project folder.

### Creating Python Interface
To control the programmable logic (PL) operation, you need to create a software hardware interface based on Python. You can do this by creating a `python3 notebook` inside the **jahwa_daq_system** folder, putting the following code into the notebook, and running them in sequence.

First, you need to import all the required libraries. The libraries are divided into three categories, which are Python library, PYNQ library, and user-defined library. The Python library is the standard library that comes with the Python installation. The PYNQ library is the library that comes with the PYNQ framework. The user-defined library is the library that you create to control the MicroBlaze operation. The user-defined library is located inside the **library** folder in the repository.

```python
##################################################################################################
#                                         Import Library                                         #
##################################################################################################
# Python library
import re
import csv
import time
import random
import asyncio

# PYNQ library
from pynq import Overlay
from pynq.lib import PynqMicroblaze

# User-defined library
from library.packet import *
from library.microblaze_revised import *
```

Next, you need to initialize the FPGA overlay and configure the MicroBlaze processor. To do this, first you need to load the overlay by calling the `Overlay()` function and passing the bitstream file path as the argument. After that, you need to define the MicroBlaze processor block by passing the MicroBlaze block name and reset name as the argument. The MicroBlaze block name and reset name can be found in the Vivado block design. The MicroBlaze block name is the name of the MicroBlaze block in the block design, and the reset name is the name of the reset block that is connected to the MicroBlaze block. After defining the MicroBlaze block, you need to instantiate the MicroBlaze class by passing the MicroBlaze block and binary file from Vitis as the argument. The MicroBlaze class is a class that contains all the functions for controlling the MicroBlaze processor. The MicroBlaze class is located inside the **library** folder in the repository.


```python
##################################################################################################
#                                          Main Program                                          #
##################################################################################################
if __name__ == "__main__":
    print('##########################################################################')
    print('#                          Loading FPGA Overlay                          #')
    print('##########################################################################')
    # Load overlay
    ol = Overlay("./bitstream/jahwa_daq_system.bit")

    # Print status
    print("FPGA Overlay loaded successfully")
    print()

    print('##########################################################################')
    print('#                        Configuring Softprocessor                       #')
    print('##########################################################################')
    # Define softprocessor block
    SoftProcessor = {
        'ip_name': ol.mb_softprocessor_0.description["memories"]["axi_bram_ctrl_0"]["fullpath"],
        'rst_name': "xlslice_0", #'mb_iop_pmoda_reset',
        'intr_pin_name': "mb_softprocessor_0/dff_en_reset_vector_0/q",
        'intr_ack_name': "xlslice_1"#'mb_iop_pmoda_intr_ack'
    } 

    # Instantiate microblaze class
    _microblaze = MicroBlaze(SoftProcessor, "./bitstream/pynq_mb_firmware.bin")

    # Check microblaze state
    print("Microblaze state: {}".format(_microblaze.state))
    print()
```

After configuring the MicroBlaze processor, you can now call functions inside the microblaze library to control the IP blocks connected to the MicroBlaze processor. The list of functions inside the microblaze library can be found in the table below.

| Function Name | IP Block | Description |
| :--- | :--- | :--- |
| `write_mailbox(data_offset, data)`       | MicroBlaze | Used for writing data to ARM core and MicroBlaze shared memory space |
| `read_mailbox(data_offset, num_words)`       | MicroBlaze | Used for reading data from ARM core and MicroBlaze shared memory space |
| `write_blocking_command(command)`       | MicroBlaze | Used for controlling the MicroBlaze to run the command that is define when creating firmware in Vitis. It should be noted that this function is blocking function. So, Python code will halt until the MicroBlaze finish running the command |
| `write_non_blocking_command(command)`       | MicroBlaze | Used for controlling the MicroBlaze to run the command that is define when creating firmware in Vitis. It should be noted that this function is non-blocking function. So, Python code will keep running while MicroBlaze execute the command |
| `gpio_write_led(led_state)`       | GPIO | Used for controlling the PYNQ board LED by writing the LED state to 0 (OFF) or 1 (ON) |
| `gpio_test_led()`                 | GPIO | Used for test MicroBlaze GPIO control by running test pattern on onboard LED |
| `gpio_write_adc(adc_state)`       | GPIO | Used for controlling the ADC power by writing the ADC state to 0 (OFF) or 1 (ON) |
| `gpio_write_sdn1(sdn1_state)`      | GPIO | Used for controlling the DAC power **(VDD OIS)** by writing the SDN1 state to 0 (OFF) or 1 (ON) |
| `gpio_write_sdn2(sdn2_state)`      | GPIO | Used for controlling the DAC power **(VDD AF)** by writing the SDN2 state to 0 (OFF) or 1 (ON) |
| `gpio_write_sdn3(sdn3_state)`      | GPIO | Used for controlling the DAC power **(VDDM)** by writing the SDN3 state to 0 (OFF) or 1 (ON) |
| `gpio_write_relay1(relay1_state)`    | GPIO | Used for controlling the relay to switch between static and active measurement by writing relay1 state to 0 (OFF) or 1 (ON) |
| `gpio_write_relay2(relay2_state)`    | GPIO | Used for controlling the relay to switch between static and active measurement by writing relay2 state to 0 (OFF) or 1 (ON) |
| `spi_config_dac(channel_num, channel_code)`    | SPI | Used for configuring DAC by writing configuration code through SPI protocol. This function receive channel number (0, 1, 2) and channel code (hex) as arguments |
| `spi_read_adc(sample_num, interval_ms)`    | SPI | Used for reading ADC output by passing number of ADC for oversampling and interval between sampling in miliseconds as arguments |
| `i2c_meissner_reset()`    | I2C | Used for resetting the Meissner sensor by writing commands through I2C protocol |
| `i2c_meissner_read(slave_addr, addr_len, data_len, reg_addr)`    | I2C | Used to read data from Meissner sensor using I2C protocol |
| `i2c_meissner_write(slave_addr, addr_len, data_len, reg_addr, data_buf)`    | I2C | Used to write data to Meissner sensor using I2C protocol |
| `i2c_meissner_chip_id()`    | I2C | Used for reading the Meissner sensor chip ID by writing commands through I2C protocol |
| `i2c_meissner_version()`    | I2C | Used for reading the Meissner sensor version by writing commands through I2C protocol |
| `i2c_meissner_unique_id()`    | I2C | Used for reading the Meissner sensor unique id by writing commands through I2C protocol |
| `laser_trigger(division_ratio)`    | AXI Clock Divider | Used for generating series of pulse for triggering the laser. This function receive the division ration arguments to control the pulse period. The pulse period is derived by dividing the division ration with FPGA fabric clock |
| `timer_test_delay()`    | AXI Timer | Used for testing the internal timer accuracy |
| `timer_get_sec()`    | AXI Timer | Used for getting internal timer time in second |
| `timer_get_cnt_val(dev_id, timer_id)`    | AXI Timer | Used for getting the timer counter count. This function receives device id and timer id as arguments. |

-------------

## :movie_camera: Tutorial Video
### Creating New Vitis Application Project


https://github.com/kaistseed/jahwa-project/assets/29477096/7735d3dc-b8d3-4cf3-87f4-235babb9f782


### Updating Makefile for Custom IP Blocks and Initial Project Build


https://github.com/kaistseed/jahwa-project/assets/29477096/06b281fc-9a73-4e16-a735-bd7db0be5ff4


### Building Project and Generate BIN File


https://github.com/kaistseed/jahwa-project/assets/29477096/f2d7344a-6de2-4293-9caf-e97f4206d796



